layer_input <- layer_dense(units = 128, activation = 'relu', input_shape = c(784), name = 'input')
layer_dropout <- layer_dropout(rate = 0.2, name = 'dropout')
layer_output <- layer_dense(units = 10, activation = 'softmax', name = 'output')
layer_dropout <- layer_dropout(rate = 0.2, name = 'dropout')
layer_dropout <- layer_dropout(rate = 0.2, name = 'dropout')
layer_input <- layer_dense(units = 128, activation = 'relu', input_shape = c(784), name = 'input')
layer_dropout <- layer_dropout(rate = 0.2, name = 'dropout')
# Criar as camadas
layer_input <- layer_dense(units = 128, activation = 'relu', input_shape = c(784), name = 'input')
layer_dropout <- layer_dropout(rate = 0.2, name = 'dropout')
layer_output <- layer_dense(units = 10, activation = 'softmax', name = 'output')
# Criar as camadas
layer_input <- layer_dense(units = 128, activation = 'relu', input_shape = c(784), name = 'input')
layer_dropout <- layer_dropout(rate = 0.2)
layer_output <- layer_dense(units = 10, activation = 'softmax', name = 'output')
layer_input <- layer_dense(units = 128, activation = 'relu', input_shape = c(784), name = 'input')
layer_dropout <- layer_dropout(rate = 0.2, input_shape = c(128))
layer_input <- layer_dense(units = 128, activation = 'relu', input_shape = c(784), name = 'input')
layer_dropout <- layer_dropout(rate = 0.2, input_shape = c(128))
# Criar as camadas
layer_input <- layer_dense(units = 128, activation = 'relu', input_shape = c(784), name = 'input')
layer_dropout <- layer_dropout(rate = 0.2, input_shape = c(128))
layer_output <- layer_dense(units = 10, activation = 'softmax', name = 'output')
# Criar as camadas
layer_dropout <- layer_dropout(rate = 0.2, input_shape = 128)
# Criar as camadas
layer_input <- layer_dense(units = 128, activation = 'relu', input_shape = c(784), name = 'input')
layer_dropout <- layer_dropout(rate = 0.2, input_shape = 128)
layer_output <- layer_dense(units = 10, activation = 'softmax', name = 'output')
# Definir e compilar o modelo
model <- keras_model_sequential() %>%
layer_dense(units = 128, activation = 'relu', input_shape = c(784)) %>%
layer_dropout(rate = 0.2) %>%
layer_dense(units = 10, activation = 'softmax')
# Compilar o modelo
model %>% compile(
loss = 'sparse_categorical_crossentropy',
optimizer = optimizer_adam(),
metrics = c('accuracy')
)
# Definir e compilar o modelo
model <- keras_model_sequential() %>%
layer_dense(units = 128, activation = 'relu', input_shape = c(784)) %>%
layer_dropout(rate = 0.2) %>%
layer_dense(units = 10, activation = 'softmax')
tensorflow::tf_config()
tensorflow::tf_config()
use_condaenv("tf-m1", required = TRUE)
tensorflow::tf_config()
use_condaenv("r-reticulate", required = TRUE)
tensorflow::tf_config()
use_condaenv("tf-m1", required = TRUE)
mnist <- dataset_mnist()
#Não consegui acessar o link diretamente devido ao protocolo de certificação SSL
#Por este motivo baiexei o arquivo mnist.npz e salvando na pasta do livro e fiz a abertura diretamente
caminho <- setwd("/Users/lincoln/Documents/GitHub/livro_deep_learning_with_R_2edition/cap2_the_mathematical_building_blocks_of_neural_networks")
mnist <- dataset_mnist(path = paste(caminho,"/mnist.npz", sep=""))
mnist <- dataset_mnist()
print(tf$config$list_physical_devices('GPU'))
#Analisando a base MNIST
mnist
print(tf$config$list_physical_devices('GPU'))
gw()
getgw()
getwd()
train_images <- mnist$train$x
train_labels <- mnist$train$y
test_images <- mnist$test$x
test_labels <- mnist$test$y
str(train_images)
str(train_labels)
train_images <- array_reshape(train_images, c(60000, 28 * 28))
model <- keras_model_sequential(list(
layer_dense(units = 512, activation = "relu"),
layer_dense(units = 10, activation = "softmax")
))
summary(model)
compile(model,
optimizer = "rmsprop",
loss = "sparse_categorical_crossentropy",
metrics = "accuracy")
model %>%
compile(
optimizer = "rmsprop",
loss = "sparse_categorical_crossentropy",
metrics = "accuracy")
model <- keras_model_sequential() %>%
layer_dense(units = 128, activation = 'relu', input_shape = c(784)) %>%
layer_dropout(rate = 0.2) %>%
layer_dense(units = 10, activation = 'softmax')
# Compilar o modelo
model %>% compile(
optimizer = optimizer_rmsprop(),
loss = 'sparse_categorical_crossentropy',
metrics = c('accuracy')
)
model <- keras_model_sequential(list(
layer_dense(units = 512, activation = "relu"),
layer_dense(units = 10, activation = "softmax")
))
train_images <- mnist$train$x
train_labels <- mnist$train$y
test_images <- mnist$test$x
test_labels <- mnist$test$y
model <- keras_model_sequential(list(
layer_dense(units = 512, activation = "relu"),
layer_dense(units = 10, activation = "softmax")
))
train_images <- array_reshape(train_images, c(60000, 28 * 28))
train_images <- train_images / 255
test_images <- array_reshape(test_images, c(10000, 28 * 28))
test_images <- test_images / 255
train_images
fit(model, train_images, train_labels, epochs = 5, batch_size = 128)
library(keras)
library(tensorflow)
library(reticulate)
use_condaenv("r-reticulate", required = TRUE)
print(tf$config$list_physical_devices('GPU'))
#Não consegui acessar o link diretamente devido ao protocolo de certificação SSL
#Por este motivo baiexei o arquivo mnist.npz e salvando na pasta do livro e fiz a abertura diretamente
caminho <- setwd("/Users/lincoln/Documents/GitHub/livro_deep_learning_with_R_2edition/cap2_the_mathematical_building_blocks_of_neural_networks")
mnist <- dataset_mnist(path = paste(caminho,"/mnist.npz", sep=""))
train_images <- mnist$train$x
train_labels <- mnist$train$y
test_images <- mnist$test$x
test_labels <- mnist$test$y
model <- keras_model_sequential(list(
layer_dense(units = 512, activation = "relu"),
layer_dense(units = 10, activation = "softmax")
))
compile(model,
optimizer = "rmsprop",
loss = "sparse_categorical_crossentropy",
metrics = "accuracy")
train_images <- array_reshape(train_images, c(60000, 28 * 28))
train_images <- train_images / 255
test_images <- array_reshape(test_images, c(10000, 28 * 28))
test_images <- test_images / 255
fit(model, train_images, train_labels, epochs = 5, batch_size = 128)
model %>% fit(
x = train_images,
y = train_labels,
epochs = 5,
batch_size = 128,
validation_split = 0.2  # opcional: dividir os dados de treinamento em treinamento e validação
)
keras::fit(model, train_images, train_labels, epochs = 5, batch_size = 128)
tensorflow::::fit(model, train_images, train_labels, epochs = 5, batch_size = 128)
tensorflow::fit(model, train_images, train_labels, epochs = 5, batch_size = 128)
keras::fit(model, train_images, train_labels, epochs = 5, batch_size = 128)
compile(model,
optimizer = "rmsprop",
loss = "sparse_categorical_crossentropy",
metrics = "accuracy")
print(tf$config$list_physical_devices('GPU'))
keras::compile(model,
optimizer = "rmsprop",
loss = "sparse_categorical_crossentropy",
metrics = "accuracy")
keras::fit(model, train_images, train_labels, epochs = 5, batch_size = 128)
fashion_mnist <- dataset_fashion_mnist()
library(keras)
library(tensorflow)
library(reticulate)
use_condaenv("tf-m1", required = TRUE)
print(tf$config$list_physical_devices('GPU'))
library(keras)
library(tensorflow)
library(reticulate)
use_condaenv("tf-m1", required = TRUE)
py_config()
use_condaenv("tf-m1", required = TRUE)
py_config()
py_config()
library(keras)
library(tensorflow)
use_condaenv("tf-m1", required = TRUE)
py_config()
use_condaenv("tf-m1", required = TRUE)
py_config()
library(reticulate)
use_condaenv("tf-m1", required = TRUE)
py_config()
print(tf$config$list_physical_devices('GPU'))
fashion_mnist <- dataset_fashion_mnist()
c(train_images, train_labels) %<-% fashion_mnist$train
c(test_images, test_labels) %<-% fashion_mnist$test
class_names = c('T-shirt/top',
'Trouser',
'Pullover',
'Dress',
'Coat',
'Sandal',
'Shirt',
'Sneaker',
'Bag',
'Ankle boot')
dim(train_images)
dim(train_labels)
train_labels[1:20]
dim(test_images)
dim(test_labels)
library(tidyr)
library(ggplot2)
image_1 <- as.data.frame(train_images[1, , ])
colnames(image_1) <- seq_len(ncol(image_1))
image_1$y <- seq_len(nrow(image_1))
image_1 <- gather(image_1, "x", "value", -y)
image_1$x <- as.integer(image_1$x)
ggplot(image_1, aes(x = x, y = y, fill = value)) +
geom_tile() +
scale_fill_gradient(low = "white", high = "black", na.value = NA) +
scale_y_reverse() +
theme_minimal() +
theme(panel.grid = element_blank())   +
theme(aspect.ratio = 1) +
xlab("") +
ylab("")
train_images <- train_images / 255
test_images <- test_images / 255
par(mfcol=c(5,5))
par(mar=c(0, 0, 1.5, 0), xaxs='i', yaxs='i')
for (i in 1:25) {
img <- train_images[i, , ]
img <- t(apply(img, 2, rev))
image(1:28, 1:28, img, col = gray((0:255)/255), xaxt = 'n', yaxt = 'n',
main = paste(class_names[train_labels[i] + 1]))
}
model <- keras_model_sequential()
model %>%
layer_flatten(input_shape = c(28, 28)) %>%
layer_dense(units = 128, activation = 'relu') %>%
layer_dense(units = 10, activation = 'softmax')
model %>% compile(
optimizer = 'adam',
loss = 'sparse_categorical_crossentropy',
metrics = c('accuracy')
)
library(keras)
library(tensorflow)
library(reticulate)
#Não consegui acessar o link diretamente devido ao protocolo de certificação SSL
#Por este motivo baiexei o arquivo mnist.npz e salvando na pasta do livro e fiz a abertura diretamente
caminho <- setwd("/Users/lincoln/Documents/GitHub/livro_deep_learning_with_R_2edition/cap2_the_mathematical_building_blocks_of_neural_networks")
mnist <- dataset_mnist(path = paste(caminho,"/mnist.npz", sep=""))
#Analisando a base MNIST
mnist
digit <- mnist$train$x[1,,]
plot(as.raster(digit, max = 255))
use_condaenv("r-reticulate", required = TRUE)
py_config()
use_condaenv("r-reticulate", required = TRUE)
print(tf$config$list_physical_devices('GPU'))
install.packages("keras")
tensorflow::tf_config()
print(tf$config$list_physical_devices('GPU'))
print(tf$config$list_physical_devices('GPU'))
use_condaenv("r-reticulate", required = TRUE)
train_images <- mnist$train$x
train_labels <- mnist$train$y
test_images <- mnist$test$x
test_labels <- mnist$test$y
model <- keras_model_sequential(list(
layer_dense(units = 512, activation = "relu"),
layer_dense(units = 10, activation = "softmax")
))
model <- keras::keras_model_sequential(list(
layer_dense(units = 512, activation = "relu"),
layer_dense(units = 10, activation = "softmax")
))
model <- keras::keras_model_sequential(list(
keras::layer_dense(units = 512, activation = "relu"),
keras::layer_dense(units = 10, activation = "softmax")
))
keras::compile(model,
optimizer = "rmsprop",
loss = "sparse_categorical_crossentropy",
metrics = "accuracy")
keras::compile(model,
keras::optimizer = "rmsprop",
keras::compile(model,
keras::optimizer = "rmsprop",
keras::compile(model,
optimizer = "rmsprop",
loss = "sparse_categorical_crossentropy",
metrics = "accuracy")
keras::compile(model,
keras::optimizer = "rmsprop",
model %>%
keras::compile(
keras::optimizer = "rmsprop",
model %>%
keras::compile(
keras::optimizer = "rmsprop",
model %>%
keras::compile(
keras::optimizer = "rmsprop",
model %>%
keras::compile(
keras::optimizer = "rmsprop",
model %>%
keras::compile(
keras::optimizer = "rmsprop",
model <- model %>%
keras::compile(
keras::optimizer = "rmsprop",
keras::compile(model,
keras::optimizer = "rmsprop",
tensorflow::tf_config()
install.packages("keras")
use_condaenv("r-reticulate", required = TRUE)
use_condaenv("tf-m1", required = TRUE)
use_condaenv("r-reticulate", required = TRUE)
library(keras)
library(tensorflow)
library(reticulate)
use_condaenv("r-reticulate", required = TRUE)
install_keras(envname = "r-reticulate", version = "2.16.1")
py_config()
#Não consegui acessar o link diretamente devido ao protocolo de certificação SSL
#Por este motivo baiexei o arquivo mnist.npz e salvando na pasta do livro e fiz a abertura diretamente
caminho <- setwd("/Users/lincoln/Documents/GitHub/livro_deep_learning_with_R_2edition/cap2_the_mathematical_building_blocks_of_neural_networks")
mnist <- dataset_mnist(path = paste(caminho,"/mnist.npz", sep=""))
use_condaenv("r-reticulate", required = TRUE)
py_config()
print(tf$config$list_physical_devices('GPU'))
tensorflow::tf_config()
train_images <- mnist$train$x
train_labels <- mnist$train$y
test_images <- mnist$test$x
test_labels <- mnist$test$y
model <- keras::keras_model_sequential(list(
keras::layer_dense(units = 512, activation = "relu"),
keras::layer_dense(units = 10, activation = "softmax")
))
keras::compile(model,
keras::optimizer = "rmsprop",
model <- keras::keras_model_sequential(list(
layer_dense(units = 512, activation = "relu"),
layer_dense(units = 10, activation = "softmax")
))
keras::compile(model,
optimizer = "rmsprop",
loss = "sparse_categorical_crossentropy",
metrics = c("accuracy"))
keras::compile(model,
keras::optimizer = "rmsprop",
compile(model,
keras::optimizer = "rmsprop",
model %>%
compile(
keras::optimizer = "rmsprop",
model %>%
compile(
optimizer = "rmsprop",
loss = "sparse_categorical_crossentropy",
metrics = c("accuracy"))
model %>%
compile(
optimizer = "rmsprop",
loss = "sparse_categorical_crossentropy",
metrics = c("accuracy"))
model <- keras::keras_model_sequential(list(
layer_dense(units = 512, activation = "relu"),
layer_dense(units = 10, activation = "softmax")
))
model <- keras::keras_model_sequential(list(
layer_dense(units = 512, activation = "relu"),
layer_dense(units = 10, activation = "softmax")
))
compile(model,
optimizer = "rmsprop",
loss = "sparse_categorical_crossentropy",
metrics = c("accuracy"))
model <- keras::keras_model_sequential(list(
layer_dense(units = 512, activation = "relu"),
layer_dense(units = 10, activation = "softmax")
)) %>%
compile(model,
optimizer = "rmsprop",
loss = "sparse_categorical_crossentropy",
metrics = c("accuracy"))
model <- keras::keras_model_sequential(list(
layer_dense(units = 512, activation = "relu"),
layer_dense(units = 10, activation = "softmax")
)) %>%
compile(model,
optimizer = "rmsprop",
loss = "sparse_categorical_crossentropy",
metrics = c("accuracy"))
model <- keras::keras_model_sequential(list(
layer_dense(units = 512, activation = "relu"),
layer_dense(units = 10, activation = "softmax")
))
model <- keras::keras_model_sequential(list(
layer_dense(units = 512, activation = "relu"),
layer_dense(units = 10, activation = "softmax")
))
model <- keras::keras_model_sequential(list(
layer_dense(units = 512, activation = "relu"),
layer_dense(units = 10, activation = "softmax")
))
model <- keras::keras_model_sequential(list(
layer_dense(units = 512, activation = "relu"),
layer_dense(units = 10, activation = "softmax")
))
model <- keras_model_sequential(list(
layer_dense(units = 512, activation = "relu"),
layer_dense(units = 10, activation = "softmax")
))
model <- keras_model_sequential(list(
layer_dense(units = 512, activation = "relu"),
layer_dense(units = 10, activation = "softmax")
))
compile(model,
optimizer = "rmsprop",
loss = "sparse_categorical_crossentropy",
metrics = "accuracy")
tensorflow::tf_config()
mnist <- dataset_mnist()
compile(model,
optimizer = "rmsprop",
loss = "sparse_categorical_crossentropy",
metrics = "accuracy")
model <- keras_model_sequential(list(
layer_dense(units = 512, activation = "relu"),
layer_dense(units = 10, activation = "softmax")
))
compile(model,
optimizer = "rmsprop",
loss = "sparse_categorical_crossentropy",
metrics = "accuracy")
use_condaenv("r-reticulate", required = TRUE)
#Instalando e carregando as bibliotecas necessárias
install.packages("keras")
install_keras(envname = "r-reticulate", version = "2.16.1")
virtualenv_create("r-reticulate", python = install_python())
library(reticulate)
install_keras(envname = "r-reticulate", version = "2.16.1")
install_keras(envname = "r-reticulate", version = "2.16.1")
virtualenv_create("r-reticulate", python = install_python())
install_keras(envname = "r-reticulate", version = "2.16.1")
compile(model,
optimizer = "rmsprop",
loss = "sparse_categorical_crossentropy",
metrics = "accuracy")
kerass::compile(model,
optimizer = "rmsprop",
loss = "sparse_categorical_crossentropy",
metrics = "accuracy")
keras::compile(model,
optimizer = "rmsprop",
loss = "sparse_categorical_crossentropy",
metrics = "accuracy")
library(keras)
library(tensorflow)
library(reticulate)
virtualenv_create("r-reticulate", python = install_python())
install_keras(envname = "r-reticulate", version = "2.16.1")
install_tensorflow(envname = "r-reticulate")
#Não consegui acessar o link diretamente devido ao protocolo de certificação SSL
#Por este motivo baiexei o arquivo mnist.npz e salvando na pasta do livro e fiz a abertura diretamente
caminho <- setwd("/Users/lincoln/Documents/GitHub/livro_deep_learning_with_R_2edition/cap2_the_mathematical_building_blocks_of_neural_networks")
mnist <- dataset_mnist(path = paste(caminho,"/mnist.npz", sep=""))
#Analisando a base MNIST
mnist
digit <- mnist$train$x[1,,]
plot(as.raster(digit, max = 255))
use_condaenv("r-reticulate", required = TRUE)
py_config()
print(tf$config$list_physical_devices('GPU'))
mnist <- dataset_mnist()
tensorflow::tf_config()
train_images <- mnist$train$x
train_labels <- mnist$train$y
test_images <- mnist$test$x
test_labels <- mnist$test$y
model <- keras_model_sequential(list(
layer_dense(units = 512, activation = "relu"),
layer_dense(units = 10, activation = "softmax")
))
compile(model,
optimizer = "rmsprop",
loss = "sparse_categorical_crossentropy",
metrics = "accuracy")
install.packages("keras")
compile(model,
optimizer = "rmsprop",
loss = "sparse_categorical_crossentropy",
metrics = "accuracy")
compile(model,
optimizer = "rmsprop",
loss = "sparse_categorical_crossentropy",
metrics = "accuracy")
keras::compile(model,
optimizer = "rmsprop",
loss = "sparse_categorical_crossentropy",
metrics = "accuracy")
install.packages("tensorflow")
library(tensorflow)
install_tensorflow()
install.packages("keras")
library(keras)
install_keras()
library(keras)
mnist <- dataset_mnist()
X_train <- mnist$train$x
X_test <- mnist$test$x
y_train <- mnist$train$y
y_test <- mnist$test$y
mnist <- dataset_mnist()
